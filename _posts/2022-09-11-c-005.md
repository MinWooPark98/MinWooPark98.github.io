---
title: "[C] C언어 기초 및 주요 문법 정리"
excerpt: "C언어 기초 및 주요 문법 정리"

categories:
  - C
tags:
  - [C, 기초]

permalink: /c/c-5/

toc: true
toc_sticky: true

date: 2022-09-11
last_modified_at: 2022-09-11
---

## C언어의 특징
- 절차지향적 언어
- 장점: 메모리의 사용량을 줄이고, 컴퓨터와 처리 구조가 유사하여 실행속도가 빠르다.
- 단점: 유지보수가 어렵고, 코드가 길어지면 다른 언어에 비해 가독성이 매우 떨어진다.

---

## 프로그램 실행 순서
- 프로그램 작성
- 컴파일 실행
- 링크 실행
- 실행 파일 생성, 파일 실행

### 순서별 오류 원인
- 컴파일 에러: 문법적 오류 (맞춤법, 미선언 변수 사용 등) 있을 때 발생
- 링크 에러: 선언한 헤더파일 또는 함수가 존재하지 않는 경우 등 코드를 연결할 때 발생
- 런타임 에러: 대표적인 오류로 segmentation fault 는 허용되지 않은 메모리에 접근할 때 주로 발생하며, 그 외에도 무한루프 등 작성된 대로 프로그램을 실행할 수 없을 때 발생

---

## 함수
- 정의 및 선언, 호출, 인자의 전달 단계를 거쳐 사용 가능
- 출력형태(반환형태), 함수이름, 입력형태로 표시된다.
- 표준함수: 이미 만들어져 기본적으로 제공되는 함수
  - 표준 라이브러리를 불러옴으로써 이용할 수 있다. ex) #include <stdio.h>

### 매개변수(parameter)와 인자(argument)
- 매개변수는 함수의 정의부에 포함되어, 함수가 호출되어 실행될 때 값을 전달받는 변수를 의미한다.
- 인자는 함수 호출 시 필요한 값을 전달하는 실제값을 의미한다.
- Call-by-value밖에 존재하지 않는 C언어에서는 매개변수를 통해 인자의 값을 직접 변경할 수 없다.
- Call-by-reference로 함수를 호출한 경우, 매개변수의 값을 변경하면, 인자의 값에도 직접적인 영향을 끼친다.
---

## 자료형

### 정수
- char(1byte), shore(2byte), int(4byte), long(4byte), long long(8byte)
- 대표적으로 int를 사용한다.
- 다른 형태로 선언되어도 계산 중에는 int형으로 형 변환되어 계산된다.
- 음의 정수 표현 방식
  - 2의 보수를 취해준다.
  - 2의 보수: 해당 정수의 비트를 반전시킨 후(1의 보수) 1을 더해준다.
### 실수형
- float(4byte), double(8byte), long double(8byte 이상)
- 대표적으로 double을 사용한다. (게임 제작에서는 주로 float 사용)
- 소수점 아래를 표현하기 위해 부동 소수점 방식을 사용한다.
  - 표현할 수 있는 값의 범위가 넓어진 대신, 정밀도가 낮아진다.
  - 오차가 존재하기 때문에 항상 정확한 값을 나타낼 수는 없다.
### 변수 선언 규칙
- 알파벳, 숫자, 언더바(_)만 사용 가능
- 대소문자는 다르게 식별
- 숫자로 시작 불가 
- 변수의 이름으로 키워드 사용 불가
- 이름 사이에 공백 사용 불가

---

## 상수

### 리터럴 상수
- 값이 변하지 않는 고정된 수
- 정수, 문자는 int형, 실수는 double형으로 표현된다.
- (Visual Studio에서 C언어에서는 리터럴 상수인 문자가 int형으로 변환되어 4byte로 확인되지만 C++에서는 1byte로 확인된다)
 
### 심볼릭 상수
- const 키워드 또는 #define을 통해 심볼릭 상수를 정의한다.
- 심볼릭 상수로 정의되면 더 이상 그 값을 변경할 수 없다.
- const키워드의 활용은 프로그램의 안정성을 높여주므로, 특히 포인터를 사용한다면 적재적소에 자주 쓰는 것이 좋다.

---

## 연산자

### 대입 연산자
- = : 연산자 우측의 값을 좌측의 변수에 대입한다.

### 산술 연산자
- +, -, *, /, % : 수학의 연산자와 같으며, 정수의 경우 /는 몫, %는 나머지를 계산한다.

### 복합 대입 연산자
- +=, -=, *=, /=, %= : 반복 작성하는 연산자를 간소화하기 위해 사용한다.

### +연산자, -연산자
- +, - : 피연산자 좌측에 써서 부호를 나타낸다. (+는 의미 없음)
- 복합 대입 연산자와 혼동하지 않도록 띄어쓴다. ex) num1 = -num2;
### 증가, 감소 연산자
- ++, -- : 메모리에 저장된 **변수의 값은 바로 변경되나 해당 연산 과정에서 쓰이는 값은 위치에 따라 다르다**.
- 피연산자 앞에 연산자가 붙는 경우: 메모리에 저장된 값이 계산에 쓰인다. ex) ++num
- 피연산자 뒤에 연산자가 붙는 경우: 메모리에 저장뒤기 이전의 값이 계산에 쓰인다. ex) num++

### 관계 연산자
- <, <=, >, >=, ==, != : 연산자 양 옆의 피연산자 간의 관계를 묻기 위해 쓰인다.
- 연산의 결과를 true, false로 반환한다.

### 논리 연산자
- &&, || : 논리값을 받아 다시 논리값을 반환한다.

### 콤마 연산자
- 둘 이상의 변수를 동시에 선언하거나, 둘 이상의 문자를 한 행에 삽입할 때 사용한다.
- 콤마 연산자는 연산이 아닌 구분을 목적으로 쓰인다.

### 비트 연산자
- &, |, ^ : 양 측의 피연산자를 비트 단위로 해당 연산한다.
- ~ : 단항 연산자로 피연산자의 비트를 모두 반전시킨다.
- <<, >> : 피 연산자의 비트 열을 좌측 또는 우측으로 한 칸씩 이동시킨다.

### sizeof() 연산자
- sizeof도 연산자의 일종으로 ( )안의 피연산자의 크기를 계산한다.

### 조건 연산자 (삼항 연산자)
- (조건문)? data1 : data2 
- 위과 같은 형태로 쓰이며 조건이 참이면 data1 반환, 거짓이면 data2를 반환한다.

---

## 형 변환

### 암시적 형 변환 (자동 형 변환)
- 대입 연산자 양 측의 자료형이 다를 경우, 좌측을 기준으로 형 변환이 발생한다.
- 정수의 계산 시 cpu가 계산하기 가장 적합한 크기인 int형으로 변환되어 계산되며, 이를 정수의 승격에 의한 자동 형 변환이라 한다.
- 산술 연산에서 피연산자 간에 자료형이 다를 경우에도 자동으로 형 변환이 진행되며, 이 때의 규칙은 다음과 같다.
  - 바이트 크기가 큰 자료형이 우선시된다.
  - 정수형보다 실수형이 우선시된다.
  
### 명시적 형 변환
- 프로그래머가 의도적으로 실행하는 형 변환이다.
- 변환하고자 하는 값 앞에 (변환하고자 하는 자료형)을 써준다.
- 자동 형 변환이 발생하는 위치에도 명시적 형 변환 표시를 해주어 형 변환이 발생함을 알리는 것이 가독성에 좋다.

---

## 흐름 제어

### 반복문
- while(조건문){ 반복문 }
  - 조건문이 true일 때 반복문 실행
- do{ 반복문 } while(조건문)
  - 반복문을 1회 실행 후 조건문이 true라면 다시 반복문 실행
- for(초기식; 조건식; 증감식) { 반복문 }
  - 조건식이 true면 반복문 실행, 반복문 끝날 때마다 증감식 적용

### 분기문
- if(조건문) { 실행문 }
  - 조건문이 true이면 실행문 실행
  - else, if else를 사용해 조건을 더할 수 있다.
- switch(변수) { case(값): 실행문 }
  - (변수)의 값이 해당하는 case의 실행문 실행
  - 반복문을 빠져나가는 동작을 직접 해주지 않으면 모든 검사를 다 실행하므로, 이를 의도한 경우가 아니라면 case문 안에 항상 break를 포함해야 한다.

---

## 포인터

- 포인터 변수는 주소값을 저장하는 변수이며, 64비트 시스템에서는 8바이트의 값을 저장한다.
- 배열의 이름은 배열의 첫 주소를 가리키는 포인터이다.
  - ex) *(arr + i) = arr[i] 와 같다.
- 리터럴 상수형을 char* 의 문자형 포인터 변수로 받게 되면 값의 변경이 불가능하다. (Visual Studio C++ 에서는 const char* 형태가 아니면 선언할 떄부터 에러)
- const 키워드가 자료형 좌측에 붙으면 주소에 저장된 값이 상수화된다.
- const 키워드가 자료형 우측에 붙으면 주소값이 상수화된다.
- ex) const int* ptr 은 (*ptr)이 상수화, int* const ptr 은 ptr이 상수화