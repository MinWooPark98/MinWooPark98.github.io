---
title: "[C] Call by value와 Call by reference의 차이"
excerpt: "Call by value / Call by reference"

categories:
  - C
tags:
  - [C, Call-by-value]

permalink: /c/c-3/

toc: true
toc_sticky: true

date: 2022-09-05
last_modified_at: 2022-09-05
---

## 🦥 Call-by-value VS Call-by-reference

- Call by value: 값에 의한 호출로 매개변수를 통해 인자의 값을 전달받아 사용한다.
- Call by reference: 참조에 의한 호출로 매개변수가 인자와 같은 주소값을 사용하게 된다.
<br/>
C언어에서 Call-by-reference는 존재하지 않으며, 모든 함수호출은 Call-by-value로 이루어진다.

---

### 무엇이 다른가?

- 값에 의한 함수 호출은 매개변수의 값만을 전달받기 때문에, 직접적으로 인자에게 영향을 끼치지 않는다.
- 이는 포인터를 사용할 떄에도 마찬가지로 인자의 값을 직접적으로 변경할 수 없다.
- 참조에 의한 함수 호출은 매개변수가 인자의 주소를 참조했기 때문에, 함수 내에서의 매개 변수 값의 변화가 인자에게 직접 영향을 끼친다.

---

### 왜 포인터는 Call-by-value일까?

``` C
void func(int n)
{
  printf("%d", n);
}
```
- 위와 같이 값에 의한 함수 호출은 매개변수를 선언하고 인자를 통해 같은 자료형의 값을 전달받게 된다.
- 이 때, n이라는 변수가 새롭게 생성되어 메모리(스택)의 한 자리를 차지하고, 해당 메모리에 인자의 값이 할당된다.
- n값이 바뀌어도 실제 인자의 값은 변하지 않는다.
<br/>

``` C

void func(int* ptr)
{
  *ptr += 1;
}
```
- 포인터를 사용한다면 해당 포인터가 가리키는 주소의 값을 변경할 수 있다.
- 그러나 인자의 값을 변경할 수는 없다.
- 이는 마찬가지로 ptr이라는 매개변수가 새롭게 생성되어, 인자의 값을 같은 포인터 자료형으로 받았을 뿐이기 때문이다.
<br/>

``` C++

void func(int& n)
{
  n += 1;
}
int t = 1;
func(t);

```
- 위의 매개변수는 참조자를 이용한 참조 변수이다. (&는 address연산자가 아닌 참조자로 쓰였다)
- 참조자는 C언어에는 존재하지 않으며, 메모리 공간을 부르는 별칭(또 다른 이름)과 같은 개념이다.
- 즉, 매개변수 n을 선언할 때 새롭게 메모리를 할당하지 않고 인자인 t의 주소를 공유하게 되며, n값의 변화와 t값의 변화가 모두 한 메모리 공간에서 진행된다. 
- 이러한 호출을 Call by reference(참조에 의한 호출)이라 하며, 값을 복사하지 않고 직접 참조하기에 Call-by-value에 비해 빠르고 매개변수를 쓰기 위해 메모리를 사용하지 않는다는 장점이 있다.

---

### 요약
- **C언어에서는 모든 함수 호출이 Call-by-value로 이루어진다.**
- **Call-by-value는 매개변수를 사용하기 위해 메모리를 할당하고 값을 복사한다.**
  - 장점: 인자의 값을 복사해 사용하기 때문에 인자의 값을 바꾸지 않는다. (안전하다)
  - 단점: 함수를 사용할 때마다 매개변수를 선언해야 하기 때문에 메모리의 사용량이 늘어난다.
- **Call-by-reference는 인자의 메모리 주소를 매개변수가 참조하여 사용한다**
  - 장점: 직접 주소를 참조하기 때문에 속도가 빠르고 메모리의 사용량이 줄어든다.
  - 단점: 함수 내에서 매개변수의 값의 변화가 인자에게도 영향을 끼치므로 조심해서 사용해야 한다.(값을 바꾸지 않을 때는 웬만해서는 const 사용)
